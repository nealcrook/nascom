#!/usr/bin/perl
#
# Manipulator for PolyDos disk images. Designed to act as a virtual file system
# for disk analysis, extract, import, copy, creation, conversion.
#
# Mostly designed for interactive use but also allows limited non-interactive
# use. Derived from a version I wrote for FLEX; this version is far simpler.
#
# https://github.com/nealcrook/nascom
#
# TODO: the import/export commands are incomplete. The current status is:
#
# conv_export_raw DONE
# conv_export_txt DONE
# conv_export_dump
# conv_export_nas
# conv_export_cas
# conv_export_nasg
# conv_export_casg
# conv_import_raw DONE
# conv_import_txt PART-DONE
# conv_import_nas DONE needs tidy
# conv_import_cas PART-DONE needs tidy

# bug: make nascom convert (And others) report file name as they go
# - looks at bad formats in files and see if it can be accommodated
# - try to extract execution address

# FUTURE: add optional y/n arg to delete.
# FUTURE: THEN (command separator)
# FUTURE: allow target of copy to be unique fs rather than simply drive name (ie copy
# file with different name)
# FUTURE: record inode so that we cannot double-mount a drive.
# TODO: fs in check_arg can return a wildcard. May want a variant xfs that returns
# exactly one file - avoid over-use of legal_poly_name. Only affects commands that create
# new files; currently import, rename, create.
# BUG: pressing CTRL-D results in lots of PERL warnings
# BUG: I think a set of bugs will occur if the disk becomes full (zero free sectors).
# TODO: when only 1 image is mounted, make drive number optional/implicit to save typing
# ..this can be done in check_arg fs match: if no :N present, and only 1 drive mounted,
# bolt on the drive number in the same way as 1 is turned into *.*:1
# TODO: allow delete to accept a list of file names.. should be an easy loop in cmd_delete
# but make sure it doesn't interfere with wildcarding.. each element of the list could be a
# wildcard.


use strict;
no strict 'refs'; # CLI makes subroutine from command name.
use warnings;
use File::Basename;

# PolyDos constants
my $FCB_BASE = 0xc418;
my $FCB_SIZE = 20;
my $FCB_OFFSET = 24;
my $FCB_COUNT = 50;

my $SFLG_DEL = 2;
my $SFLG_LOK = 1;

# Bytes per sector
my $BYTES_SECTOR = 256;
# Sectors per disk - default for 35track DS, DD
my $SECTORS = 35*2*18;

my $cmdline;

# For 'type' command
my $LINES_PER_PAGE = 40;

# For 'uppercase' command
my $UPCASE = 0;

# Main data structure (populated by &rd_dir):
# $dsk[0..3]
# $dsk[n]->{mounted} boolean
# $dsk[n]->{handle} file handle
# $dsk[n]->{blks} number of blocks -- INFERRED from reading the image
# $dsk[n]->{filename} file name by which file was accessed
# filled in by rd_dir when disk is mounted:
# $dsk[n]->{dname} disk name in ASCII
# $dsk[n]->{nxtsec} next sector
# $dsk[n]->{nxtfcb} next fcb address - 1st fcb is $c418, 2nd is $c418 + 20 etc.
# $dsk[n]->{fcbval} number of valid fcbs. INFERRED from {nxtfcb} - valid fcbs are 0..fcbval-1
# $dsk[n]->{fcb}->[n]-> fcb 0-49
# $dsk[n]->{fcb}->[n]->{fnam}
# $dsk[n]->{fcb}->[n]->{fext}
# $dsk[n]->{fcb}->[n]->{fsfl}
# $dsk[n]->{fcb}->[n]->{fufl}
# $dsk[n]->{fcb}->[n]->{fsec}
# $dsk[n]->{fcb}->[n]->{fnsc}
# $dsk[n]->{fcb}->[n]->{flda}
# $dsk[n]->{fcb}->[n]->{fexa}
my @dsk;

# The other data structure that's used a lot is a hash, %f, which is
# passed around as a reference, thus "$f_ref". It is used as a temporary
# thing for storing stuff about a single file.
# For a file export, %f starts off being populated with stuff from the file's
# FCB. For a file import, %f ends up being populated with a superset of stuff
# needed for an FCB; the file creation step of the import involves putting
# the %f into the $dsk data structure. Thus, the keys of %f are a superset
# of the keys of an FCB (fnam, fext, fsfl, fufl, fsec, fnsc, flda, fexa)


if (defined $ARGV[0]) {
    while (my $file = shift @ARGV) {
        cmd_mount(0,$file);
        cmd_info("");
        cmd_check(0);
        my $drive = "0"; # gets modified by arg processing
        cmd_dir($drive);
        cmd_umount(0);
        print "\n";
    }
    exit;
}


# Command-line interpreter
while (1) {
    print "polydos_vfs: ";
    my $cmd = <>;
    $cmdline = $cmd; # save for later
    if (not -t STDIN) {
        # non-interactive, so echo input to output
        print $cmd;
    }
    chomp $cmd;
    # remove comments (like this) #or like this
    $cmd =~ s/\(.*\)//g;
    $cmd =~ s/\#.*$//;
    next if ($cmd eq "");

    my @bits = split " ", $cmd;
    my $sub = "cmd_$bits[0]";
    if (defined(&{$sub})) {
        shift @bits;
        &{$sub}(@bits);
    }
    else {
        print "ERROR: no command \'$bits[0]\'\n";
    }
}


#################################################################
#################################################################
## Commands

sub cmd_mount {
    my ($drive, $file) = check_arg('v h', @_);
    return unless defined($drive);

    if ($dsk[$drive]->{mounted}) {
        print "ERROR virtual drive $drive is already mounted.\n";
        return;
    }

    if (open $dsk[$drive]->{handle}, '+<', $file) {
        # so far so good
        $dsk[$drive]->{filename} = $file;

        # size the disk image
        my $tmp;
        $dsk[$drive]->{blks} = 0;
        seek $dsk[$drive]->{handle}, 0, 0;
        while (my $actual = read $dsk[$drive]->{handle}, $tmp, $BYTES_SECTOR) {
            if ($actual == $BYTES_SECTOR) {
                $dsk[$drive]->{blks} = $dsk[$drive]->{blks} + 1;
            }
            else {
                print "ERROR image is not a multiple of $BYTES_SECTOR. Mount aborted.\n";
                return;
            }
        }

        if ($dsk[$drive]->{blks} != $SECTORS) {
            print "WARNING image has $dsk[$drive]->{blks} sectors - expected the default of $SECTORS\n";
        }

        # cache the directory for easy access
        rd_dir($drive);

        # finally
        $dsk[$drive]->{mounted} = 1;
    }
    else {
        # Unlikely - it opened OK in check_arg
        print "ERROR could not re-open $file\n";
    }
}


sub cmd_clone {
    my ($drive, $file) = check_arg('mv nh', @_);
    return unless defined($drive);

    if (open my $handle, '>', $file) {
        seek $dsk[$drive]->{handle}, 0, 0;
        my $data;
        for my $blk (1..$dsk[$drive]->{blks}) {
            # read a block
            my $actual = read $dsk[$drive]->{handle}, $data, $BYTES_SECTOR;
            if ($actual == $BYTES_SECTOR) {
                # write a block
                print $handle $data;
            }
            else {
                close $handle;
                die "FATAL internal error - failed to read data\n";
            }
        }
        close $handle;
    }
    else {
        # Unlikely - it opened OK in check_arg
        print "ERROR could not re-open $file\n";
    }
}


sub cmd_info {
    my $report = 0;
    for my $drive (0..3) {
        if ($dsk[$drive]->{mounted}) {
            print "Drive $drive: Host file: $dsk[$drive]->{filename}\n";
            describe($drive);
            $report++;
        }
    }
    if ($report == 0) {
        print "No drives are mounted\n";
    }
}


sub cmd_umount {
    my ($drive) = check_arg('mv', @_);
    return unless defined($drive);

    close $dsk[$drive]->{handle};
    $dsk[$drive]->{mounted} = 0;
}


sub cmd_new {
    my ($file, $sectors) = check_arg('nh os', @_);
    return unless defined ($file);

    # Arbitrary..
    if ($sectors < 10) {
        print "ERROR cannot have so few sectors\n";
        return;
     }

    if (open my $handle, '>', $file) {
        my @data;
        # DNAME
        for (my $i=0; $i<20; $i=$i+1) {
            $data[$i] = ord ' ';
        }
        # NXTSEC
        $data[20] = 4;
        $data[21] = 0;
        # NXTFCB
        $data[22] = 0x18;
        $data[23] = 0xc4;
        # FCBs - 50 entries of 20 bytes each
        for (my $i=0; $i<$FCB_COUNT; $i=$i+1) {
            for (my $j=0; $j<20; $j=$j+1) {
                push @data, 0xe5
            }
        }

        my $data = pack("C*", @data);
        # directory
        print $handle $data;

        @data = ();
        for (my $i=0; $i<$BYTES_SECTOR; $i=$i+1) {
            $data[$i] = 0xe5; # formatted floppy disk data value
        }
        $data = pack("C*", @data);

        for (my $i=4; $i<$sectors; $i=$i+1) {
            # data
            print $handle $data;
        }
        close $handle;
    }
    else {
        # Unlikely - it opened OK in check_arg
        print "ERROR could not re-open $file\n";
    }
}


sub cmd_copy {
    my ($fs, $dst) = check_arg('fs v', @_);
    return unless defined($fs);

    my ($file,$ext,$src) = fs_to_fed($fs);

    if (not $dsk[$src]->{mounted}) {
        print "ERROR source drive $src is not mounted\n";
        return;
    }
    if (not $dsk[$dst]->{mounted}) {
        print "ERROR destination drive $dst is not mounted\n";
        return;
    }
    if ($src == $dst) {
        print "ERROR cannot copy to the same drive\n";
        return;
    }

    my $cp_match = filter_dir($src,$file,$ext,'NON-DELETED');
    # which of those names already in use at the destination?
    my $rm_match = index_match_dir($src,$cp_match,$dst);

    print " INFO 0 files match $src.$file:$ext\n" if scalar @$cp_match == 0;

    # is there enough space for the copy?
    my $dst_free = free_sectors($dst) + sectors($dst, $rm_match);
    if ($dst_free < sectors($src, $cp_match)) {
        print "ERROR insufficient space for copy\n";
        return;
    }

    # are there enough directory entries for the copy?
    my $dst_dir_entries = dir_entries($dst) + scalar(@$rm_match);
    if (scalar(@$cp_match) > $dst_dir_entries) {
        print "ERROR insufficient directory entries for copy\n";
        return;
    }

    rm_files($dst, $rm_match);
    cp_files($src, $cp_match, $dst);
}


sub cmd_rename {
    my ($old, $new) = check_arg('fs fs', @_);
    return unless defined($old);

    my ($ofile,$oext,$drive) = fs_to_fed($old);
    my ($nfile,$next,$ndrive) = fs_to_fed($new);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }
    if ($drive != $ndrive) {
        print "ERROR cannot rename across drives. Use copy instead\n";
        return;
    }

    my $old_match = filter_dir($drive, $ofile,$oext,'NON-DELETED');
    my $new_match = filter_dir($ndrive,$nfile,$next,'NON-DELETED');

    if (scalar @$old_match != 1) {
        printf "ERROR source must match exactly 1 file. Matched %d files\n", scalar @$old_match;
        return;
    }
    if (scalar @$new_match > 1) {
        printf "ERROR new name must match no more than 1 file. Matched %d files\n", scalar @$new_match;
        return;
    }
    if ((scalar @$new_match == 1) && ($old_match->[0] == $new_match->[0])) {
        print "ERROR cannot rename a file to itself.\n";
        return;
    }

    if (scalar @$new_match == 1) {
        # Delete existing file that matches the new name
        rm_files($drive, $new_match);
    }

    $dsk[$drive]->{fcb}->[$old_match->[0]]->{fnam} = $nfile;
    $dsk[$drive]->{fcb}->[$old_match->[0]]->{fext} = $next;
    wr_dir($drive);
}


sub cmd_name {
    my ($drive, $name) = check_arg('mv n',@_);
    return unless defined($drive);

    $dsk[$drive]->{dname} = $name;
}


sub cmd_type {
    my ($fs, $conv_ref, $lpp) = check_arg('fs oec oi', @_);
    return unless defined($fs);

    $lpp = defined $lpp ? $lpp : $LINES_PER_PAGE;
    # defaults 'type' (unless already set on command-line)
    $conv_ref->{tx}  = exists $conv_ref->{tx}  ? $conv_ref->{tx}  : "txt";
    $conv_ref->{go}  = exists $conv_ref->{go}  ? $conv_ref->{go}  : "dump";
    $conv_ref->{xxx} = exists $conv_ref->{xxx} ? $conv_ref->{xxx} : "dump";

    type_export_common($fs, $conv_ref, $lpp, "", 0);
}


# The main work is done by subroutines conv_export_<format>
sub cmd_export {
    my ($fs, $conv_ref, $path) = check_arg('fs oec od', @_);
    return unless defined($fs);

    $path = defined $path ? $path . "/" : "";
    # defaults for 'export' (unless already set on command-line)
    exists $conv_ref->{tx}  or $conv_ref->{tx}  = 'txt';
    exists $conv_ref->{go}  or $conv_ref->{go}  = 'raw';
    exists $conv_ref->{xxx} or $conv_ref->{xxx} = 'raw';

    type_export_common($fs, $conv_ref, 0, $path, 1);
}


sub type_export_common {
    my ($fs, $conv_ref, $lpp, $path, $export) = @_;

    my ($file,$ext,$drive) = fs_to_fed($fs);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext,'NON-DELETED');

    printf " INFO %d files match $file.$ext:$drive\n", scalar @$match if scalar @$match != 1;

    export_files($drive, $match, $conv_ref, $lpp, $path, $export);
}


# The main work is done by subroutines conv_import_<format>
sub cmd_import {
    my ($dst, $hf_names, $path, $conv_ref) = check_arg('mv hfw oic', @_);
    return unless defined($dst);

    # defaults for 'import' (unless already set on command-line)
    exists $conv_ref->{xxx} or $conv_ref->{xxx} = 'raw';
    exists $conv_ref->{nas} or $conv_ref->{nas} = 'nas';
    exists $conv_ref->{cas} or $conv_ref->{cas} = 'cas';

    # are there enough directory entries for the import?
    if (scalar(@$hf_names) > dir_entries($dst)) {
        printf "ERROR insufficient directory entries for import: need %d, only have %d\n",
            scalar(@$hf_names), dir_entries($dst);
        return;
    }

    # Some files will change name on import, both because names might be truncated and because
    # extensions might change as a result of the importers being used. In addition, the import list
    # itself might end up deleting files as it proceeds.
    #
    # Cannot work out how much space they will take up, because the file size is dependent on the
    # conversion that's used. Instead, do the conversion of all of the files and hold the converted
    # data in a data-structure, then add up the total needed before committing to perform the import.
    # The reason for caring whether it will fit is that it's messy if an import part-fits because it's
    # tedious to work out what imported and what did not.

    my $skip = 0;
    my $total_sectors = 0;
    my @ff;
    foreach my $i (@$hf_names) {
        my %f;
        if (open $f{handle} , "$path$i") {
            my (undef, $host_ext) = split /\./, $i;
            $host_ext = lc $host_ext;
            # if no converter is defined for this file extension, use the default converter
            exists $conv_ref->{$host_ext}  or $conv_ref->{$host_ext} = $conv_ref->{xxx};

            ($f{fnam}, $f{fext}) = legalise_filename($i);
            $f{flda} = 0;
            $f{fexa} = 0;

            # run the converter to populate {data}
            printf " INFO run importer %5s on %15s\n", $conv_ref->{$host_ext}, $i;
            my $conv = 'conv_import_' . $conv_ref->{$host_ext};
            &{$conv}(\%f);

            my $sectors = pad_to_sector(\%f);
            printf "    ..imported as %8s.%s (%d sectors)\n", $f{fnam}, $f{fext}, $sectors;
            $total_sectors = $total_sectors + $sectors;
            close $f{handle};
            push @ff,\%f;
        }
        else {
            print "ERROR skipped import of $path$i -- cannot open\n";
            $skip = $skip + 1;
        }
    }

    # is there enough space for the import?
    if ($total_sectors > free_sectors($dst)) {
        printf "ERROR insufficient space for import: need %d sectors, only have %d\n",
            $total_sectors, free_sectors($dst);
        return;
    }

    # do the import. For each file in turn, delete an existing file of the same name, if any.
    foreach my $f_ref (@ff) {
        # build directory entry by adding remaining fcb keys to $f_ref
        $f_ref->{fsfl} = 0;
        $f_ref->{fufl} = 0;
        $f_ref->{fsec} = $dsk[$dst]->{nxtsec};

        if (delete_existing($dst, $f_ref)) {
            print " INFO delete existing file $f_ref->{fnam}.$f_ref->{fext}\n";
        }

        # add the directory entry and write the data
        $dsk[$dst]->{fcb}->[$dsk[$dst]->{fcbval}] = $f_ref;
        $dsk[$dst]->{fcbval} = $dsk[$dst]->{fcbval} + 1;
        $dsk[$dst]->{nxtfcb} = $dsk[$dst]->{nxtfcb} + $FCB_SIZE;
        wr_dsec($dst, $f_ref->{fsec}, $f_ref->{data});
        $dsk[$dst]->{nxtsec} = $dsk[$dst]->{nxtsec} + $f_ref->{fnsc};
    }
    # Update directory on disk for all the imported files.
    wr_dir($dst);

    printf " INFO %d files imported (%d skipped), using %d sectors\n",
        scalar(@$hf_names) - $skip, $skip, $total_sectors;
}


# directory of host - just pass all arguments to host
sub cmd_hdir {
    system "dir @_";
}


# directory is in $dsk - just filter/print it here.
# All of these are legal:
# dir 1    dir 1.fred.bin   dir 1.*.bin   dir 2.fr*.*
# the first (just the drive specified) is a special case and
# is converted (by check_arg) into 1.*.* so that can be treated
# in the same way as the other forms.
sub cmd_dir {
    my ($fs) = check_arg('fs', @_);
    return unless defined($fs);

    my ($file,$ext,$drive) = fs_to_fed($fs);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext,'ALL');

    print "   Sect Nsct Load Exec SysFlg   Name\n";

    foreach my $i (@{$match}) {
        my $j = $dsk[$drive]->{fcb}->[$i];
        # system flags
        my $sfl = "        ";
        if ($j->{fsfl} & $SFLG_LOK) {substr($sfl, 0, 1) = "L"};
        if ($j->{fsfl} & $SFLG_DEL) {substr($sfl, 1, 1) = "D"};

        printf "   %04x %04x %04x %04x %s %s.%s\n",
            $j->{fsec}, $j->{fnsc}, $j->{flda}, $j->{fexa},
            $sfl, $j->{fnam}, $j->{fext};
    }
}


# TODO: currently accepts "delete fs". Change it to "delete fs [fs..]" ie multiple file specifiers - each
# of which is run through the match/rm_files/rd_dir sequence in turn.
sub cmd_delete {
    my ($fs) = check_arg('fs', @_);
    return unless defined($fs);

    my ($file,$ext,$drive) = fs_to_fed($fs);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext,'NON-DELETED');

    printf " INFO %d files match $file.$ext:$drive\n", scalar @$match if scalar @$match != 1;

    rm_files($drive, $match);
}


sub cmd_undelete {
    my ($fs) = check_arg('fs', @_);
    return unless defined($fs);

    my ($file,$ext,$drive) = fs_to_fed($fs);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext,'DELETED');

    if (scalar @$match == 0) {
        print "ERROR there is no deleted file with that name.\n";
        return;
    }

    # in a previous version of the code I did a filter_dir looking
    # to see if there was >0 non-deleted file matches. That's no
    # good though when a wildcard's in use.. consider the command:
    # undelete *.OV:0
    # one or more of the deleted files might have a non-deleted
    # equivalent, but one or more might not. Therefore, need to
    # consider each undelete candidate separately.
    # If there are multiple deleted files with the same name, this
    # will undelete the oldest and report an error for the others
    my $names_ref = names_ref($drive);
    foreach my $i (@{$match}) {
        my $name = "$dsk[$drive]->{fcb}->[$i]->{fnam}.$dsk[$drive]->{fcb}->[$i]->{fext}";
        if (exists $names_ref->{$name}) {
            print "ERROR skipped undelete of $name - there is already a file with that name.\n";
        }
        else {
            $dsk[$drive]->{fcb}->[$i]->{fsfl} = $dsk[$drive]->{fcb}->[$i]->{fsfl} & (0xff ^ $SFLG_DEL);
            # need this to prevent undeletion of another copy next time round the loop
            $names_ref->{$name} = $i;
        }
    }
    wr_dir($drive);
}


sub cmd_lock {
    my ($fs) = check_arg('fs', @_);
    return unless defined($fs);

    my ($file,$ext,$drive) = fs_to_fed($fs);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext,'NON-DELETED');

    printf " INFO %d files match $file.$ext:$drive\n", scalar @$match if scalar @$match != 1;

    foreach my $i (@{$match}) {
        $dsk[$drive]->{fcb}->[$i]->{fsfl} = $dsk[$drive]->{fcb}->[$i]->{fsfl} | $SFLG_LOK;
    }
    wr_dir($drive);
}


sub cmd_unlock {
    my ($fs) = check_arg('fs', @_);
    return unless defined($fs);

    my ($file,$ext,$drive) = fs_to_fed($fs);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext,'NON-DELETED');

    printf " INFO %d files match $file.$ext:$drive\n", scalar @$match if scalar @$match != 1;

    foreach my $i (@{$match}) {
        $dsk[$drive]->{fcb}->[$i]->{fsfl} = $dsk[$drive]->{fcb}->[$i]->{fsfl} & (0xff ^ $SFLG_LOK);
    }
    wr_dir($drive);
}


sub cmd_attrib {
    my ($fs, $new_fexa, $new_flda) = check_arg('fs hi ohi', @_);
    return unless defined($new_fexa);

    my ($file,$ext,$drive) = fs_to_fed($fs);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext,'NON-DELETED');

    printf " INFO %d files match $file.$ext:$drive\n", scalar @$match if scalar @$match != 1;

    # must have $new_fexa
    foreach my $i (@{$match}) {
        $dsk[$drive]->{fcb}->[$i]->{fexa} = hex $new_fexa;
    }
    # may have $new_flda;
    if (defined $new_flda) {
        foreach my $i (@{$match}) {
            $dsk[$drive]->{fcb}->[$i]->{flda} = hex $new_flda;
        }
    }
    wr_dir($drive);
}


sub cmd_pack {
    my ($drive) = check_arg('mv', @_);
    return unless defined($drive);

    my $dir_step = 0;
    my $sec_step = 0;
    for (my $i=0; $i<$dsk[$drive]->{fcbval}; $i=$i+1) {
        if ($dsk[$drive]->{fcb}->[$i]->{fsfl} & $SFLG_DEL) {
            # this is a deleted file - account for it
            $dir_step = $dir_step + 1;
            $sec_step = $sec_step + $dsk[$drive]->{fcb}->[$i]->{fnsc};
        }
        elsif ($dir_step == 0) {
            # this is a non-deleted file but there have been no
            # deleted files - nothing to do
        }
        else{
            # this is a non-deleted file and there have been 1 or
            # more deleted files. Shuffle this file down to fill
            # the gap.
            # First, copy the directory entry - accounting for the new start sector
            $dsk[$drive]->{fcb}->[$i-$dir_step]->{fnam} = $dsk[$drive]->{fcb}->[$i]->{fnam};
            $dsk[$drive]->{fcb}->[$i-$dir_step]->{fext} = $dsk[$drive]->{fcb}->[$i]->{fext};
            $dsk[$drive]->{fcb}->[$i-$dir_step]->{fsfl} = $dsk[$drive]->{fcb}->[$i]->{fsfl};
            $dsk[$drive]->{fcb}->[$i-$dir_step]->{fufl} = $dsk[$drive]->{fcb}->[$i]->{fufl};
            $dsk[$drive]->{fcb}->[$i-$dir_step]->{fsec} = $dsk[$drive]->{fcb}->[$i]->{fsec} - $sec_step;
            $dsk[$drive]->{fcb}->[$i-$dir_step]->{fnsc} = $dsk[$drive]->{fcb}->[$i]->{fnsc};
            $dsk[$drive]->{fcb}->[$i-$dir_step]->{flda} = $dsk[$drive]->{fcb}->[$i]->{flda};
            $dsk[$drive]->{fcb}->[$i-$dir_step]->{fexa} = $dsk[$drive]->{fcb}->[$i]->{fexa};
            # Next, copy the data
            my $data = rd_dsec($drive, $dsk[$drive]->{fcb}->[$i]->{fsec}, $dsk[$drive]->{fcb}->[$i]->{fnsc});
            wr_dsec($drive, $dsk[$drive]->{fcb}->[$i]->{fsec} - $sec_step, $data);
        }
    }
    # Finally, update the directory with the number of free directory entries and free sectors
    $dsk[$drive]->{nxtfcb} = $dsk[$drive]->{nxtfcb} - $dir_step * $FCB_SIZE;
    $dsk[$drive]->{fcbval} = $dsk[$drive]->{fcbval} - $dir_step;
    $dsk[$drive]->{nxtsec} = $dsk[$drive]->{nxtsec} - $sec_step;
    wr_dir($drive);
}


sub cmd_create {
    my ($fs, $sectors) = check_arg('fs i', @_);
    return unless defined($fs);

    my ($file,$ext,$drive) = fs_to_fed($fs);

    if (not $dsk[$drive]->{mounted}) {
        print "ERROR drive $drive is not mounted\n";
        return;
    }

    my $match = filter_dir($drive,$file,$ext,'NON-DELETED');

    if (scalar @$match != 0) {
        printf "ERROR file specifier must not match existing file. Matched %d files\n", scalar @$match;
        return;
    }

    if (dir_entries($drive) == 0) {
        print "ERROR insufficient directory entries for create\n";
        return;
    }

    my $name = "$file.$ext";
    if (not legal_poly_name($name)) {
        print "ERROR cannot resolve $name to a unique/legal name.\n";
        return;
    }

    if ($sectors > free_sectors($drive)) {
        print "ERROR insufficient free sectors.\n";
        return;
    }

    # make new directory entry and reserve space for the data
    my $f_ref = empty_f_ref();
    $f_ref->{fnam} = $file;
    $f_ref->{fext} = $ext;
    $f_ref->{fsec} = $dsk[$drive]->{nxtsec};
    $dsk[$drive]->{nxtsec} = $dsk[$drive]->{nxtsec} + $sectors;
    $f_ref->{fnsc} = $sectors;

    # add the directory entry and increment fcb count
    $dsk[$drive]->{fcb}->[$dsk[$drive]->{fcbval}] = $f_ref;
    $dsk[$drive]->{fcbval} = $dsk[$drive]->{fcbval} + 1;
    $dsk[$drive]->{nxtfcb} = $dsk[$drive]->{nxtfcb} + $FCB_SIZE;

    # Update directory on disk
    wr_dir($drive);
}


sub cmd_repair {
    print "repair TODO - not yet implemented\n";
}


# Look at the valid directory entries, ignoring whether files are deleted or not.
# Make sure that:
# - sectors allocated to files start at 4
# - sectors are allocated sequentially and contiguously
# - the free sector follows on from the last allocated sector
sub cmd_check {
    my ($drive) = check_arg('mv', @_);
    return unless defined($drive);

    my $error = 0;
    my $sec_expect = 4;
    for (my $i=0; $i<$dsk[$drive]->{fcbval}; $i=$i+1) {
        my $sec = $dsk[$drive]->{fcb}->[$i]->{fsec};
        my $num = $dsk[$drive]->{fcb}->[$i]->{fnsc};

        if ($sec != $sec_expect) {
            print "ERROR for directory entry $i, expected start sector of $sec_expect but read $sec\n";
            $error = $error + 1;
        }
        $sec_expect = $sec + $num;
    }

    if ($sec_expect != $dsk[$drive]->{nxtsec}) {
        print "ERROR next sector to be allocated ($dsk[$drive]->{nxtsec}) does not match sector after last file ($sec_expect)\n";
        $error = $error + 1;
    }

    if ($error == 0) {
        print " INFO check completed with no errors\n";
    }
}


sub cmd_scrub {
    my ($drive) = check_arg('mv', @_);
    return unless defined($drive);

    my @data;
    for (my $i=0; $i<$BYTES_SECTOR; $i=$i+1) {
        $data[$i] = 0xe5; # formatted floppy disk data value
    }
    my $datas = pack("C*", @data);
    my $data2 = pack("C*", @data[0..1]);
    my $data8 = pack("C*", @data[0..7]);

    # scrub undefined entries in the directory
    for (my $i=$dsk[$drive]->{fcbval}; $i<$FCB_COUNT; $i=$i+1) {
        $dsk[$drive]->{fcb}->[$i]->{fnam} = $data8;
        $dsk[$drive]->{fcb}->[$i]->{fext} = $data2;
        $dsk[$drive]->{fcb}->[$i]->{fsfl} = 0xe5;
        $dsk[$drive]->{fcb}->[$i]->{fufl} = 0xe5;
        $dsk[$drive]->{fcb}->[$i]->{fsec} = 0xe5e5;
        $dsk[$drive]->{fcb}->[$i]->{fnsc} = 0xe5e5;
        $dsk[$drive]->{fcb}->[$i]->{flda} = 0xe5e5;
        $dsk[$drive]->{fcb}->[$i]->{fexa} = 0xe5e5;
    }

    # scrub unallocated sectors
    for (my $i=$dsk[$drive]->{nxtsec}; $i<$dsk[$drive]->{blks}; $i=$i+1) {
        wr_dsec($drive, $i, $datas);
    }
    wr_dir($drive, $FCB_COUNT);
}


sub cmd_quit {
    cmd_exit();
}


sub cmd_exit {

    foreach my $drive (0..3) {
        cmd_umount($drive) if ($dsk[$drive]->{mounted});
    }
    exit;
}


sub cmd_help {
    my ($help_for) = @_;
    if (defined $help_for) {
        help_for($help_for);
    }
    else {
        help_generic();
    }
}


sub cmd_uppercase {
    my ($flag) = check_arg('oi', @_);

    if (defined $flag) {
        $UPCASE = $flag ? 1 : 0;
    }
    else {
        $UPCASE = $UPCASE ? 0 : 1;
    }

    if ($UPCASE) {
        print "PolyDos file specifiers will be forced to upper-case\n";
    }
    else {
        print "PolyDos file specifiers will use mixed case\n";
    }
}


#################################################################
#################################################################
# Subroutines

# Check/validate a set of arguments against expected format.
# eg: check_arg('v h oec', @_);
# string of expected argument formats, followed by argument list.
# On error: print error message(s) and return nothing
# On success: return a list of valid arguments. In the simple
# case, there is a 1-to-1 mapping between the argument list/
# the input list/the output list. In some cases, though,
# additional values get inserted. See case-by-case comments.
#
# argument formats:
# v   - virtual drive number
# mv  - virtual drive number of mounted drive (error if not mounted)
# h   - existing file in host filesystem
# hfw - wildcard in host filesystem. Only recognise files that are
#       valid PolyDos file names and non-zero in size. Must match at
#       least 1 file.
# nh  - file in host filesystem (may or may not exist)
# od  - optional directory in host filesystem (must exist) default to .
# fs  - PolyDos file specifier eg: 1 or FOO.GO:1
# n   - disk name (truncated/padded to 20 characters, can
#       include spaces) - consumes all remaining arguments and so must
#       be the last entry in the format list.
# hi  - hex value (1-4 characters)
# ohi - optional hex value (1-4 characters)
# i   - integer
# oi  - optional integer
# os  - optional sector. If omitted, default value is returned.
# oic - optional import converters. Returns hash reference
# oec - optional export converters. Returns hash reference
sub check_arg {
    my @expected = split " ",(shift @_);
    my $i = 0;
    ARG: foreach my $f (@expected) {
        if (($f eq 'v') or ($f eq 'mv')) {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected virtual drive number\n";
                return;
            }
            if (($_[$i] ne "0") and ($_[$i] ne "1") and
                ($_[$i] ne "2") and ($_[$i] ne "3")) {
                print "ERROR $_[$i] is not a legal virtual drive number\n";
                return;
            }
            if (($f eq 'mv') and not $dsk[$_[$i]]->{mounted}) {
                print "ERROR drive $_[$i] is not mounted\n";
                return;
            }
        }
        elsif ($f eq 'i') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected integer\n";
                return;
            }
            if ($_[$i] !~ /^\d+$/) {
                print "ERROR $_[$i] is not an integer\n";
                return;
            }
        }
        elsif ($f eq 'oi') {
            if (defined $_[$i]) {
                if ($_[$i] !~ /^\d+$/) {
                    print "ERROR $_[$i] is not an integer\n";
                    return;
                }
            }
        }
        elsif ($f eq 'hi') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected hex value (1-4 digits)\n";
                return;
            }
            if ($_[$i] !~ /^[0-9a-fA-F]{1,4}$/) {
                print "ERROR $_[$i] is not a hex value or is too large\n";
                return;
            }
        }
        elsif ($f eq 'ohi') {
            if (defined $_[$i]) {
                if ($_[$i] !~ /^[0-9a-fA-F]{1,4}$/) {
                    print "ERROR $_[$i] is not a hex value or is too large\n";
                    return;
                }
            }
        }
        elsif ($f eq 'oec') {
            # Zero or more export conversion rules. Remove
            # them all; replace them with a single value: a hash ref.
            # An export conversion rule is of the form XXX=YYY where
            # XXX is any alphanumeric string and is the name of a
            # conversion supported for export/type. In both cases, the
            # input text is forced to lower-case.
            my %conv;
            my $first = $i;
            while ((defined $_[$i]) and ($_[$i] =~ /^\w+=\w+$/)) {
                # Looks like a conversion rule. Do everything in lower case.
                my $rule = lc $_[$i];
                if ($rule =~ /^(\w+)=(raw|txt|dump|nas|nasg|cas|casg)/) { # conversions for export
                    $conv{$1} = $2;
                }
                else {
                    print "ERROR: conversion $_[$i] does not exist or is not supported for export.\n";
                    return;
                }
                $i = $i + 1;
            }
            # replace 1 or more converters with the hash reference.
            splice @_, $first, $i-$first, \%conv;
            $i = $first;
        }
        elsif ($f eq 'oic') {
            # Zero or more import conversion rules. Remove
            # them all; replace them with a single value: a hash ref. See
            # comments above on 'oec'.
            my %conv;
            my $first = $i;
            while ((defined $_[$i]) and ($_[$i] =~ /^\w+=\w+$/)) {
                # Looks like a conversion rule. Do everything in lower case.
                my $rule = lc $_[$i];
                if ($rule =~ /^(\w+)=(raw|txt|nas|cas)/) { # conversions for import
                    $conv{$1} = $2;
                }
                else {
                    print "ERROR: conversion $_[$i] does not exist or is not supported for import.\n";
                    return;
                }
                $i = $i + 1;
            }
            # replace 1 or more converters with the hash reference.
            splice @_, $first, $i-$first, \%conv;
            $i = $first;
        }
        elsif ($f eq 'od') {
            # optional directory path. If absent caller assumes CWD.
            if (defined $_[$i]) {
                if (not opendir TMP, $_[$i]) {
                    print "ERROR cannot open directory $_[$i]\n";
                    return;
                }
                closedir TMP;
            }
        }
        elsif ($f eq 'h') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected host file name\n";
                return;
            }
            if (open my $tmp, '+<', $_[$i]) {
                # all good
                close $tmp;
            }
            else {
                print "ERROR could not open $_[$i] -- maybe it is read-only?\n";
                return;
            }
        }
        elsif ($f eq 'hfw') {
            # host wildcard; only recognise files that are valid PolyDos
            # names and non-zero in size. Must match at least 1 file.
            # Return a reference to a list of files AND a directory path
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected host file name\n";
                return;
            }
            my ($name, $path, $suffix) = fileparse($_[$i], '\..*');

            # turn the filename into a legal PERL regex: * -> [-\w]*
            #                                            . -> \.
            my $f = $name . $suffix;
            $f =~ s|\*|\[-\\w\]\*|g;
            $f =~ s|\.|\\\.|g;

            opendir DIR, $path;
            # $f is what we match for; final $ makes sure there's
            # nothing more (so that fred.dsk doesn't match fred.dsk_x)
            my @matches = grep /$f$/, readdir DIR;
            close DIR;
            @matches = grep { legal_poly_name($_) } @matches;
            @matches = grep { -s "$path$_" != 0 } @matches;

            if (not defined $matches[0]) {
                print "ERROR no matching host files - candidates must be non-zero size with legal PolyDos names\n";
                return;
            }

            $_[$i] = \@matches;
            # need the path so insert it after the files ref and skip past it
            splice @_, $i+1, 0, $path;
            $i = $i + 1;
        }
        elsif ($f eq 'nh') {
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected host file name\n";
                return;
            }
            # file may not exist so open for output
            if (open my $tmp, '>', $_[$i]) {
                # all good
                close $tmp;
            }
            else {
                print "ERROR could not open $_[$i] -- maybe it is read-only?\n";
                return;
            }
        }
        elsif ($f eq 'fs') {
            # PolyDos file specifier
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected PolyDos file specifier\n";
                return;
            }
            if ($UPCASE) {
                $_[$i] = uc $_[$i];
            }
            if (($_[$i] eq "0") or ($_[$i] eq "1") or
                ($_[$i] eq "2") or ($_[$i] eq "3")) {
                # make it more regular and we're done
                $_[$i] = "*.*:$_[$i]";
            }
            # From PolyDos Users Guide
            # 1-8 character name, 2 character extension, 0-3 for drive.
            # name/extension can contain 0-9 a-z A-Z _ - &
            # flex_vfs allows name and extension can contain * to wildcard.
            # ..and the fiddly part is that a single * can wildcard the
            # extension, which othewise would need to be 2 characters long
            if ($_[$i] !~ /^[\*\w\-\&]{1,8}\.(\*|[\w\-\&]{2,2})\:[0123]$/) {
                print "ERROR $_[$i] is not a legal file specifier\n";
                return;
            }
        }
        elsif ($f eq 'n') {
            # disk name - upto 20 characters
            if (not defined $_[$i]) {
                print "ERROR missing argument - expected disk name\n";
            }

            # disk name can include spaces so need to extract it from
            # the raw command line.
            $cmdline =~ /([a-zA-Z]+)\s+(\d*)\s(.*$)/;

            # left-justify and truncate in 20-character field.
            $_[$i] = sprintf("%-20.20s",$3);

            # required to be the last thing, so gobble any remaining arguments
            # and we're done
            $i = scalar @_;
            last ARG;
        }
        elsif ($f eq 'os') {
            # Optional s=Y. If present, Y must be numeric. Return Y
            if (defined $_[$i]) {
                if ($_[$i] =~ /^s=(\d+)$/) {
                    # sector number is OK. Rewrite with just the number
                    $_[$i] = $1;
                }
                else {
                    print "ERROR illegal size - expected s=NN got $_[$i]\n";
                    return;
                }
            }
            else {
                splice @_, $i, 0, ($SECTORS);
                $i = $i + 1;
            }
        }
        else {
            die "FATAL internal error - unknown format $f\n";
        }
        $i = $i + 1;
    }
    # Final check is that all the arguments have been used up
    if (exists $_[$i]) {
        print "ERROR unexpected argument: $_[$i]\n";
        return;
    }

    # Phew! Success!
    return @_;
}


# break a file specifier into filename, extension, drive
# eg: my ($file,$ext,$drive) = fs_to_fed($fs);
# assume file specifier is legal and fully-specified
sub fs_to_fed {
    my ($fs) = @_;
    $fs =~ /^([\w\-\&\*]+).([\w\-\&\*]+):(\d)/;
    return ($1,$2,$3)
}

# export/type zero or more files
# files specified by list of directory indices
# $export=0 -> type to screen
# $export=1 -> export to host file system at $path
sub export_files {
    my ($drive, $match, $conv_ref, $lpp, $path, $export) = @_;

    foreach my $i (@{$match}) {
        # build a data structure for use by the converter
        my %f;
        foreach my $key (keys %{$dsk[$drive]->{fcb}->[$i]}) {
            $f{$key} = $dsk[$drive]->{fcb}->[$i]->{$key};
        }

        $f{path} = $path;
        $f{data} = rd_dsec($drive, $f{fsec}, $f{fnsc});

        # pager; used if $export = 0
        $f{export} = $export;
        $f{line} = 1;
        $f{lpp} = $lpp;

        # if no converter is defined for this file extension, use the default converter
        my $ext = lc $f{fext};
        exists $conv_ref->{$ext}  or $conv_ref->{$ext} = $conv_ref->{xxx};

        # run the converter to do the conversion and save/type the result
        my $conv = 'conv_export_' . $conv_ref->{$ext};
        &{$conv}(\%f);

        if ($export) {
            close $f{handle};
        }
    }
}


# From $f_ref, use {name}, {ext} and {export} to open a file handle.
# Set {handle}. On error, {handle} is undef and the caller should return immediately.
sub set_export_handle {
    my ($f_ref) = @_;

    my $fname = $f_ref->{path} . $f_ref->{fnam} . "." . $f_ref->{fext};
    if ($f_ref->{export}) {
        if (not open $f_ref->{handle}, '>', $fname) {
            print "ERROR could not open file $fname\n";
            $f_ref->{handle} = undef;
        }
    }
    else {
        print "============= $f_ref->{fnam}.$f_ref->{fext} =============\n";
        $f_ref->{handle} = \*STDOUT;
    }
    return $f_ref->{handle};
}


# File export converter. Each has the name conv_export_* and each takes
# the same argument: an $f_ref. Each converter does 4 things:
# - it optionally modifies the output file name {fnam} {fext}
# - it calls set_export_handle to get {handle} opened
# - it performs the conversion on {data}
# - it sends the exported data to {handle}, paging if {export}
sub conv_export_raw {
    my ($f_ref) = @_;
    return if not set_export_handle($f_ref);
    my $handle = $f_ref->{handle};

    my $count = 0; # for pager
    for (my $i=0; $i<length $f_ref->{data}; $i=$i+1) {
        print $handle substr($f_ref->{data}, $i, 1);
        $count = $count + 1;

        if ($count == 256 and not $f_ref->{export}) {
            $count = 0;
            print "\nPress ENTER to continue, Q ENTER to quit";
            last if <STDIN> =~ /[qQ]/;
        }
    }
}


# Text file format. Convert CR (Ctrl-M) line endings to CR/LF
sub conv_export_txt {
    my ($f_ref) = @_;
    return if not set_export_handle($f_ref);
    my $handle = $f_ref->{handle};
    my $line = 0;    ## TODO modify to use &page like cmd_export_dump
    my $page = 0;

    for (my $i=0; $i<length $f_ref->{data}; $i=$i+1) {
        my $chr = ord substr($f_ref->{data}, $i, 1);
        next if ($chr == 0);
        if ($chr == 0x0d) {
            print $handle chr 0x0d;
            print $handle chr 0x0a;

            if ($line == $f_ref->{lpp}) {
                $line = 1;
                $page = not $f_ref->{export};
            }
            else {
                $line = $line + 1;
            }
        }
        else {
            print $handle chr $chr;
        }

        if ($page) {
            $page = 0;
            print "\nPress ENTER to continue, Q ENTER to quit";
            last if <STDIN> =~ /[qQ]/;
        }
    }
}


# Hex and ASCII dump
sub conv_export_dump {
    my ($f_ref) = @_;
    $f_ref->{fext} = 'DUMP';
    return if not set_export_handle($f_ref);
    my $handle = $f_ref->{handle};
    my $num_str = '';
    my $let_str = '';
    my $count = 0;
    my $offset = 0;

    for (my $i=0; $i<length $f_ref->{data}; $i=$i+1) {
        my $chr = ord substr($f_ref->{data}, $i, 1);

        $num_str = $num_str . ' ' . sprintf("%02x",$chr);
        if (($chr < 0x7F) and ($chr > 0x1f)) {
            $let_str = $let_str . chr $chr;
        }
        else {
            $let_str = $let_str . '.';
        }
        $count = $count + 1;

        if ($count == 8) {
            $num_str = $num_str . ' ';
            $let_str = $let_str . ' ';
        }

        if ($count == 16) {
            printf $handle "%04x%s  %s\n", $offset, $num_str, $let_str;
            $count = 0;
            $num_str = '';
            $let_str = '';
            $offset = $offset + 16;
            last if page($f_ref);
        }
    }
    # runt
    if ($count != 0) {
        my $pad = '   ' x (16 - $count);
        if ($count < 8) {
            $pad = $pad . ' ';
        }
        printf $handle "%04x%s $pad %s\n", $offset, $num_str, $let_str;
    }
}


# Export in NAS or NAS/Generate format.
sub conv_export_nasg {
    my ($f_ref) = @_;
    $f_ref->{fext} = 'NAS';
    return if not set_export_handle($f_ref);
    print "TODO conv_export_nasg\n";
}


# Export in CAS or CAS/Generate format.
sub conv_export_casg {
    my ($f_ref) = @_;
    $f_ref->{fext} = 'CAS';
    return if not set_export_handle($f_ref);
    print "TODO conv_export_casg\n";
}


# Used by export converters. Called after each output line to do paging
# if STDOUT is in use. Return true if output should be aborted.
# Reads and modifies {line}, {lpp}.
sub page {
    my ($f_ref) = @_;

    if ($f_ref->{line} == $f_ref->{lpp}) {
        $f_ref->{line} = 1;
        if (not $f_ref->{export}) {
            print "\nPress ENTER to continue, Q ENTER to quit";
            return 1 if <STDIN> =~ /[qQ]/;
        }
    }
    else {
        $f_ref->{line} = $f_ref->{line} + 1;
    }
    return 0;
}


# File import converter. Each has the name conv_import_* and each takes
# the same argument: a $f_ref. Each converter does 4 things:
# - it optionally modifies the output file name {name} {ext}
# - it uses {handle} to get the file contents
# - it builds the converted data as a binary string in {data}
# - it loads {flda} {fexa} with the load and execute address (or
#   leaves then at their default)
sub conv_import_raw {
    my ($f_ref) = @_;
    my $h = $f_ref->{handle};
    {
        # slurp
        local $/=undef;
        $f_ref->{data} = <$h>;
    }
}


sub conv_import_txt {
    my ($f_ref) = @_;
    # TODO strip CR/LF to leave CR ?? Check Polydos files in raw form
    print "TODO conv_import_txt - file is $f_ref->{fnam}.$f_ref->{fext}\n";
    $f_ref->{data} = sprintf("Result of import of $f_ref->{fnam}.$f_ref->{fext} by conv_import_txt");
}


# NAS to binary. Assume execution address matches load address.
sub conv_import_nas {
    my ($f_ref) = @_;
    my $h = $f_ref->{handle};
    $f_ref->{fext} = 'GO';

    my $load_addr;
    my @data;

    while (my $line = <$h>) {
        # By inspection of various .NAS files..
        # - line endings are inconsistent. Get rid of both CR and LF
        # - some have nulls before the line-end. Get rid of them.
        # - some have 0x08 before the line-end. Get rid of them.
        $line =~ s/[\n\r\x00\x08]//g;

        # A "." indicates exit from the L command.
        last if $line =~ /^\.$/;

        # skip blank lines (there should not be any)
        next if $line =~ /^\s*$/;

        # Lines look like this:
        # 1000 3E AA 32 EA 12 AF 32 EC F3
        #
        # Must be an address and at least 1 data byte. If there are
        # 9 bytes, the last one is a checksum of the address/data
        my @bits = split " ", $line;
        my $count = scalar(@bits) - 1;
        my $addr = hex($bits[0]);

        defined $load_addr or $load_addr = $addr;

        if ($count == 0) {
            print "ERROR bad format at line $. -- address field but no data\n";
            next;
        }
        if ($count == 9) {
            # Verify checksum then discard it by bumping $count
            my $asum = $addr + ($addr >> 8);
            my $esum = hex($bits[9]); # actual
            for (my $i=1; $i<9; $i=$i+1) {
                $asum = ($asum + hex($bits[$i])) & 0xff;
            }
            if ($asum != $esum ) {
                # report the error but use the data anyway.
                printf "ERROR bad checksum at line $. -- calculated 0x%X but read 0x%X\n", $asum, $esum;
            }
            $count = $count - 1;
        }

        for (my $i=1; $i<($count + 1); $i=$i+1) {
            if ($addr >= $load_addr) {
                my $byte = hex($bits[$i]);
                $data[$addr - $load_addr] = $byte;
                $addr = $addr + 1;
            }
            else {
                printf "ERROR discontinuity in addressing at line $. -- address went backwards\n";
            }
        }
    }

    # fill in any missing locations
    foreach my $i (0.. $#data) {
        if (not defined $data[$i]) {
            $data[$i] = 0;
            printf "ERROR filled in missing location 0x%04x\n", $load_addr + $i;
        }
    }

    $f_ref->{flda} = $load_addr;
    $f_ref->{fexa} = $load_addr; # TODO try to get execution address
    $f_ref->{data} = pack("C*", @data);
}


# CAS to binary.
sub conv_import_cas {
    my ($f_ref) = @_;
    $f_ref->{fext} = 'GO';
    $f_ref->{data} = ''; # empty
    $f_ref->{flda} = undef; # so that process_cas_blk() will fill this in

    while (find_cas_preamble($f_ref)) {
        process_cas_blk($f_ref);
    }

    ## TODO might be "G" stuff remaining

    # TODO nas to binary; grab load address -- and execution address if it exists
    #print "TODO conv_import_cas - file is $f_ref->{fnam}.$f_ref->{fext}\n";
    #$#f_ref->{data} = sprintf("Result of import of $f_ref->{fnam}.$f_ref->{fext} by conv_import_cas");
}

# seek input file to the start of the next block. Return true if found.
# TODO want to build runt string for end of file; it might contain execution address.
sub find_cas_preamble {
    my ($f_ref) = @_;
    my $h = $f_ref->{handle};

    my $byte;
    my $count = 0;
    BYTE: while (read $h, $byte, 1) {
        $byte = ord $byte;
        # looking for 0xff
        if ($byte == 0) {
            $count = 1;
            next BYTE;
        }
        # looking for 0xff
        if ($byte == 0xff) {
            $count = $count + 1;
            if ($count == 5) {
                return 1;
            }
            next BYTE;
        }
        $count = 0;
    }
    return 0;
}


# TODO use this for cas block as well, for better error reporting
# get a byte from $h
# $byte = get_byte($h, \&sub , $string)
# if no byte available execute &sub($string)
sub get_byte {
    my $h = $_[0];
    my $on_error = $_[1];
    my $on_error_arg = $_[2];

    my $byte;
    my $ok = read $h, $byte, 1;
    if ($ok == 1) {
        return ord $byte;
    }
    else {
        &$on_error($on_error_arg);
    }
}


# TODO how to carry on?
# Error when reading block header/data/footer
sub err_blk {
    my $msg = $_[0];
#    close IN;
#    close OUT;
#    printf "ERROR reached end of file while trying to read $msg for block $current_blknum\n";
    printf "ERROR reached end of file while trying to read $msg for block xxx\n";
#    exit 1;
}



# next byte from {handle} is start of block. Read block header, verify header
# checksum and block number. Read block body, append equvalent data to
# {data} and verify block body checksum.
#

# next byte is 1st byte of block. Append it to {data} etc.
# TODO need to extract/track address
sub process_cas_blk {
    my ($f_ref) = @_;
    my $h = $f_ref->{handle};

    # read 5-byte block header:
    # 2 bytes start address
    # 1 byte  block length
    # 1 byte  block number
    # 1 byte  header checksum
    # The checksum is the low 8-bits of the sum of the other 4 bytes (NOT, as
    # would be usual, a value that makes the 5 bytes sum to 0)
    my $blkaddr = get_byte($h, \&err_blk, "block address") + (get_byte($h, \&err_blk, "block address") << 8);
    my $blklen  = get_byte($h, \&err_blk, "block length");
    my $blknum  = get_byte($h, \&err_blk, "block number");
    my $blkcsum = get_byte($h, \&err_blk, "block header checksum");

    # TODO seems a bit clumsy..
    # First time around
    if (not defined $f_ref->{flda}) {
        $f_ref->{flda} = $blkaddr;
        $f_ref->{fexa} = $blkaddr;
    }

    # Verify checksum
    my $sum = 0xff & (($blkaddr & 0xff) + ($blkaddr >>8) + $blklen + $blknum);
    if ($sum != $blkcsum) {
        printf "ERROR bad header checksum in block $blknum - calculated 0x%X but read 0x%X\n", $sum, $blkcsum;
    }

    # Verify block number. Block number is an 8-bit value that counts down to 0; the cassette
    # read command terminates after block 0 has been processed.
    # Skip check for 1st block, because block number is unknown.
    if (defined $f_ref->{blk}) {
        if ($f_ref->{blk} == 0) {
            print "ERROR found block after block 0; block 0 should be the last block\n";
            # but carry on.. it would need a second R command to get the rest
            $f_ref->{blk} = $blknum;
        }
        else {
            $f_ref->{blk} = $f_ref->{blk} - 1;
        }

        if ($blknum != $f_ref->{blk}) {
            printf "ERROR bad header block number in block $blknum -- expected 0x%X but read 0x%X\n", $f_ref->{blk}, $blknum;
        }
    }

    $f_ref->{blk} = $blknum;

    # Fix up byte count
    $blklen = 256 if ($blklen == 0);

    # Read block body and append to {data}, accumulating checksum at the same time.
    my $bytes_printed = 0;
    $sum = 0;
    for (my $i=0; $i<$blklen; $i=$i+1) {
        my $byte = get_byte($h, \&err_blk, "block data");
        $f_ref->{data} = $f_ref->{data} . chr($byte);
        $sum = 0xff & ($sum + $byte);

        $blkaddr = $blkaddr + 1;
    }

    ## TODO track load address etc. etc.


    # Read block footer:
    # 1 byte  data checksum
    my $fsum = get_byte($h, \&err_blk, "block data checksum");

    if ($sum != $fsum) {
        printf "ERROR bad data checksum in block $blknum -- calculated 0x%02X but read 0x%02X\n",$sum, $fsum;
    }
}


# Is this a legal PolyDos name? Return true if it is, false otherwise.
# Must be in the form "file dot extension" where
# file contains a-zA-Z0-9_-& only and is 1-8 char
# extension starts with letter, contains a-zA-Z0-9_- only and is 2 char.
# (actually, PolyDos forbids space . , : ; and control characters but
# may allow anything else, so the check here is over-restrictive. However
# need to forbid * in names because it's used here for wildcarding)
sub legal_poly_name {
    my ($name) = @_;
    return $name =~ /^[\w\-\&]{1,8}\.[\w\-\&]{2}$/;
}


# Given a host filename, split it into name and extension and legalise each
# part as follows:
# name is 1-8 characters: upper/lower alpha, numbers, not allowed are comma,
# space, period, colon, semi-colon. Remove illegals, truncate to 8 characters
# if necessary.
# ext is exactly 2 characters: upper/lower alpha, numbers. Remove illegals,
# truncate to 2 characters if necessary, pad to 2 characters by adding z if
# necessary.
# Finally, if $UPCASE, force name and ext to caps
# Return the name and extension. eg:
# my ($name, $ext) = legalise_filename("fred.bin");
sub legalise_filename {
    my ($filename) = @_;

    my ($name, $ext) = split /\./, $filename;

    $name =~ s/\,\ \t\.\:\;//g;
    $ext  =~ s/\,\ \t\.\:\;//g;

    $ext = $ext . "xx";
    $name = substr($name, 0, 8);
    $ext  = substr($ext,  0, 2);

    if ($UPCASE) {
        $name = uc $name;
        $ext = uc $ext;
    }

    return ($name, $ext);
}


# Takes a f_ref. Null-pad {data} to a multiple of the sector size. Add an
# entry {fnsc} with the number of sectors. Return the size of the padded
# data, in sectors
sub pad_to_sector {
    my ($f_ref) = @_;

    my $runt = length($f_ref->{data}) % $BYTES_SECTOR;
    if ($runt != 0) {
        my $extra = chr(0) x ($BYTES_SECTOR - $runt);
        $f_ref->{data} = $f_ref->{data} . $extra;
    }

    my $sectors = length($f_ref->{data})/$BYTES_SECTOR;
    $f_ref->{fnsc} = $sectors;
    return $sectors;
}


# copy zero or more files
# files specified by list of directory indices on the src.
# already checked:
# - there is enough space
# - there are enough directory entries
# - there are no name clashes
sub cp_files {
    my ($src, $match, $dst) = @_;

    foreach my $i (@{$match}) {
        # make new directory entry and reserve space for the data
        my $f_ref = empty_f_ref();
        foreach my $key (keys %$f_ref) {
            $f_ref->{$key} = $dsk[$src]->{fcb}->[$i]->{$key};
        }

        $f_ref->{fsec} = $dsk[$dst]->{nxtsec};
        $dsk[$dst]->{nxtsec} = $dsk[$dst]->{nxtsec} + $f_ref->{fnsc};

        # add the directory entry and increment fcb count
        my $dst_i = $dsk[$dst]->{fcbval};
        $dsk[$dst]->{fcb}->[$dst_i] = $f_ref;
        $dsk[$dst]->{fcbval} = $dst_i + 1;
        $dsk[$dst]->{nxtfcb} = $dsk[$dst]->{nxtfcb} + $FCB_SIZE;

        # copy the data.
        my $data = rd_dsec($src, $dsk[$src]->{fcb}->[$i]->{fsec}, $dsk[$src]->{fcb}->[$i]->{fnsc});
        wr_dsec($dst, $dsk[$dst]->{fcb}->[$dst_i]->{fsec}, $data);
    }

    # update directory structure in the disk image
    wr_dir($dst);
}


# Set D (delete) flag on zero or more files
# files specified by list of directory indices
sub rm_files {
    my ($drive, $match) = @_;

    foreach my $i (@{$match}) {
        $dsk[$drive]->{fcb}->[$i]->{fsfl} = $dsk[$drive]->{fcb}->[$i]->{fsfl} | $SFLG_DEL;
    }
    wr_dir($drive);
}


# read one or more sectors, return data as a string.
# sector specified by drive, offset, number
sub rd_dsec {
    my ($drive, $start, $num) = @_;

    my $data;
    my $seek = $start * $BYTES_SECTOR;
    my $want = $num * $BYTES_SECTOR;

    if (seek $dsk[$drive]->{handle}, $seek, 0) {
        my $got = read $dsk[$drive]->{handle}, $data, $want;
        if ($got == $want) {
            return $data;
        }
        else {
            # TODO BUG: this makes it a fatal error to mount a bad file. Fix that!
            die "Could not read $want bytes at offset $seek on drive $drive";
        }
    }
    else {
        die "Could not reach offset $seek on drive $drive";
    }
}


# write one or more sectors. Write data supplied as a string - can be any length
# (any number of sectors). Sector specified by drive, sector-offset
sub wr_dsec {
    my ($drive, $start, $data) = @_;

    my $seek = $start * $BYTES_SECTOR;

    if (seek $dsk[$drive]->{handle}, $seek, 0) {
        my $fh = $dsk[$drive]->{handle};
        print $fh $data;
    }
    else {
        die "Could not reach offset $seek on drive $drive";
    }
}


# Summary of the disk image
sub describe {
    my ($drive) = @_;
    my $i = "        ";
    printf "$i Disk name: %20s\n", $dsk[$drive]->{dname};
    printf "$i Next free: 0x%04x (0x%04x sectors total)\n",  $dsk[$drive]->{nxtsec}, $dsk[$drive]->{blks};
    printf "$i Used FCBs: %d out of %d\n", $dsk[$drive]->{fcbval}, $FCB_COUNT;
}


# read directory from disk image and unpack as a data structure in $dsk.
# This is used as a read-only cache: anything that writes to the directory either
# 1/ writes to this data-structure then calls wr_dir to update the disk image or
# 2/ writes directly to the disk image then calls rd_dir to update the data-structure.
# In other words, we never keep changes lurking here between commands.
sub rd_dir {
    my ($drive) = @_;

    # Directory is in the first 4 sectors of the disk (1024 bytes). Its format
    # is described in the PolyDos System Programmers guide.
    my $data = rd_dsec($drive, 0, 4);
    my @data = unpack("C*", $data);

    $dsk[$drive]->{dname} = substr($data, 0, 20);
    $dsk[$drive]->{nxtsec} = $data[20] + 256 * $data[21];
    $dsk[$drive]->{nxtfcb} = $data[22] + 256 * $data[23];
    $dsk[$drive]->{fcbval} = ($dsk[$drive]->{nxtfcb} - $FCB_BASE)/$FCB_SIZE;

    my @fcb;
    # Only read entries from valid FCBs
    for (my $i=0; $i<$dsk[$drive]->{fcbval}; $i=$i+1) {
        my $xx = substr($data, $FCB_OFFSET + $i*$FCB_SIZE + 0, 8);
        $xx =~ s/ *$//; # delete trailing spaces
        $fcb[$i]->{fnam} = $xx;
        $xx = substr($data, $FCB_OFFSET + $i*$FCB_SIZE + 8, 2);
        $xx =~ s/ *$//; # delete trailing spaces
        $fcb[$i]->{fext} = $xx;
        $fcb[$i]->{fsfl} = $data[$FCB_OFFSET + $i*$FCB_SIZE + 10];
        $fcb[$i]->{fufl} = $data[$FCB_OFFSET + $i*$FCB_SIZE + 11];
        $fcb[$i]->{fsec} = $data[$FCB_OFFSET + $i*$FCB_SIZE + 12] +
                     256 * $data[$FCB_OFFSET + $i*$FCB_SIZE + 13];
        $fcb[$i]->{fnsc} = $data[$FCB_OFFSET + $i*$FCB_SIZE + 14] +
                     256 * $data[$FCB_OFFSET + $i*$FCB_SIZE + 15];
        $fcb[$i]->{flda} = $data[$FCB_OFFSET + $i*$FCB_SIZE + 16] +
                     256 * $data[$FCB_OFFSET + $i*$FCB_SIZE + 17];
        $fcb[$i]->{fexa} = $data[$FCB_OFFSET + $i*$FCB_SIZE + 18] +
                     256 * $data[$FCB_OFFSET + $i*$FCB_SIZE + 19];
    }

    $dsk[$drive]->{fcb} = \@fcb;
}


# Create a binary blob to match the directory data structure and write it
# to the virtual drive.
# By default, $fcbval is not supplied, and entries are ONLY written for valid
# fcbs. The resultant lump of data can be less than 4 sectors in size and leaves
# a "high-tide" mark of old but ignored entries on the disk.
# The exception is the scrub command where we want to write a complete set of
# FCBs and supply $FCB_COUNT as the $fcbval argument.
sub wr_dir {
    my ($drive, $fcbval) = @_;

    if (not defined $fcbval) {
        $fcbval = $dsk[$drive]->{fcbval};
    }

    my @data;
    # disk name
    for (my $i=0; $i<20; $i=$i+1) { $data[$i] = ord ' '; }

    for (my $i=0; $i<length $dsk[$drive]->{dname}; $i=$i+1) {
        $data[$i] = ord substr($dsk[$drive]->{dname}, $i, 1);
    }

    $data[20] = $dsk[$drive]->{nxtsec} & 0xff;
    $data[21] = $dsk[$drive]->{nxtsec} >>8;
    $data[22] = $dsk[$drive]->{nxtfcb} & 0xff;
    $data[23] = $dsk[$drive]->{nxtfcb} >>8;

    for (my $fcb=0; $fcb<$fcbval; $fcb=$fcb+1) {
        # file name and extension
        for (my $i=0; $i<10; $i=$i+1) { $data[24 + $FCB_SIZE*$fcb + $i] = ord ' '; }

        for (my $i=0; $i<length $dsk[$drive]->{fcb}->[$fcb]->{fnam}; $i=$i+1) {
            $data[24 + $FCB_SIZE*$fcb + $i] = ord (substr($dsk[$drive]->{fcb}->[$fcb]->{fnam}, $i, 1));
        }

        for (my $i=0; $i<length $dsk[$drive]->{fcb}->[$fcb]->{fext}; $i=$i+1) {
            $data[32 + $FCB_SIZE*$fcb + $i] = ord (substr($dsk[$drive]->{fcb}->[$fcb]->{fext}, $i, 1));
        }
        $data[34 + $FCB_SIZE*$fcb + 0] = $dsk[$drive]->{fcb}->[$fcb]->{fsfl};
        $data[35 + $FCB_SIZE*$fcb + 0] = $dsk[$drive]->{fcb}->[$fcb]->{fufl};
        $data[36 + $FCB_SIZE*$fcb + 0] = $dsk[$drive]->{fcb}->[$fcb]->{fsec} & 0xff;
        $data[36 + $FCB_SIZE*$fcb + 1] = $dsk[$drive]->{fcb}->[$fcb]->{fsec} >>8;
        $data[38 + $FCB_SIZE*$fcb + 0] = $dsk[$drive]->{fcb}->[$fcb]->{fnsc} & 0xff;
        $data[38 + $FCB_SIZE*$fcb + 1] = $dsk[$drive]->{fcb}->[$fcb]->{fnsc} >>8;
        $data[40 + $FCB_SIZE*$fcb + 0] = $dsk[$drive]->{fcb}->[$fcb]->{flda} & 0xff;
        $data[40 + $FCB_SIZE*$fcb + 1] = $dsk[$drive]->{fcb}->[$fcb]->{flda} >>8;
        $data[42 + $FCB_SIZE*$fcb + 0] = $dsk[$drive]->{fcb}->[$fcb]->{fexa} & 0xff;
        $data[42 + $FCB_SIZE*$fcb + 1] = $dsk[$drive]->{fcb}->[$fcb]->{fexa} >>8;
    }

    wr_dsec($drive, 0, pack("C*", @data));
}


# Given a drive number and (potentially wildcarded) file name/extension,
# return a reference to a list of the directory entries that match.
# $which is:
# NON-DELETED - consider non-deleted files only
# ALL         - consider deleted and non-deleted files
# DELETED     - consider deleted files only
sub filter_dir {
    my ($drive, $file, $ext, $which) = @_;
    my @matches;

    # turn the "all files" specifier, *, into a legal PERL regex.
    # Filename can contain \w (a-zA-Z0-9_) and - and /.
    # so change * -> [/-\w]*
    # but escaped once for the string here and again for the match below
    $file =~ s|\*|\[\\/\\-\\w\]\*|g;
    $ext =~  s|\*|\[\\/\\-\\w\]\*|g;

    for my $i (0..($dsk[$drive]->{fcbval} -1)) {
        if (($which eq 'ALL') or ($which eq 'NON-DELETED')) {
            if (($dsk[$drive]->{fcb}->[$i]->{fnam} =~ /^$file$/)
                and ($dsk[$drive]->{fcb}->[$i]->{fext} =~ /^$ext$/)
                and (($dsk[$drive]->{fcb}->[$i]->{fsfl} & $SFLG_DEL) == 0)) {
                push @matches, $i;
            }
        }
        if (($which eq 'ALL') or ($which eq 'DELETED')) {
            if (($dsk[$drive]->{fcb}->[$i]->{fnam} =~ /^$file$/)
                and ($dsk[$drive]->{fcb}->[$i]->{fext} =~ /^$ext$/)
                and (($dsk[$drive]->{fcb}->[$i]->{fsfl} & $SFLG_DEL) != 0)) {
                push @matches, $i;
            }
        }
    }
    return \@matches;
}


# $files is a ref to a list of indices to files on $drive1.
# Look for filename matches on $drive2 and return a ref
# to a list of the directory entries that match - that list
# corresponds to indices in $drive2, NOT $drive1.
sub index_match_dir {
    my ($drive1, $files, $drive2) = @_;
    my @matches;

    my $drive2_names_ref = names_ref($drive2);

    # check each name we're looking for
    foreach my $i (@{$files}) {
        my $name = "$dsk[$drive1]->{fcb}->[$i]->{fnam}.$dsk[$drive1]->{fcb}->[$i]->{fext}";
        if (exists $drive2_names_ref->{$name}) {
            push @matches, $drive2_names_ref->{$name};
        }
    }

    return \@matches;
}


# return a reference to a hash whose keys are the non-deleted files on
# the drive, and whose values are the associated fcb indices Usage:
# my $names = names_ref(0);
# if (exists $names->{ZOMBIE.GO})  { #etc }
sub names_ref {
    my ($drive) = @_;
    my $ref;

    for my $i (0.. $dsk[$drive]->{fcbval}-1) {
        next if ($dsk[$drive]->{fcb}->[$i]->{fsfl} & $SFLG_DEL);
        my $name = "$dsk[$drive]->{fcb}->[$i]->{fnam}.$dsk[$drive]->{fcb}->[$i]->{fext}";
        $ref->{$name} = $i;
    }
    return $ref;
}


# Return a reference to an empty directory entry; a hash
# reference containing the minimum set of fields.
sub empty_f_ref {
    my $f_ref;
    $f_ref->{fnam} = "";
    $f_ref->{fext} = "";
    $f_ref->{fsfl} = 0;
    $f_ref->{fufl} = 0;
    $f_ref->{fsec} = 0;
    $f_ref->{fnsc} = 0;
    $f_ref->{flda} = 0;
    $f_ref->{fexa} = 0;
    return $f_ref;
}


# sum the sectors needed to hold the specified files
sub sectors {
    my ($drive, $match) = @_;
    my $sum = 0;

    foreach my $i (@{$match}) {
        $sum = $sum + $dsk[$drive]->{fcb}->[$i]->{fnsc};
    }

    return $sum;
}


# return the number of free directory entries on $drive
sub dir_entries {
    my ($drive) = @_;

    return $FCB_COUNT - $dsk[$drive]->{fcbval};
}


# return the number of free sectors on $drive
sub free_sectors {
    my ($drive) = @_;

    return $dsk[$drive]->{blks} - $dsk[$drive]->{nxtsec};
}


# Does this file already exist as an undeleted file on $drive? If so, delete it
# and return 1. Else, return 0.
sub delete_existing {
    my ($drive, $f_ref) = @_;

    for my $i (0..($dsk[$drive]->{fcbval} -1)) {
        next if $dsk[$drive]->{fcb}->[$i]->{fsfl} & $SFLG_DEL;
        next if $dsk[$drive]->{fcb}->[$i]->{fnam} ne $f_ref->{fnam};
        next if $dsk[$drive]->{fcb}->[$i]->{fext} ne $f_ref->{fext};
        # Can be at most 1 match, so we're done
        $dsk[$drive]->{fcb}->[$i]->{fsfl} = $dsk[$drive]->{fcb}->[$i]->{fsfl} | $SFLG_DEL;
        return 1;
    }
    return 0;
}


#################################################################
#################################################################
## Help

sub help_for {
    my ($cmd) = @_;
    if ($cmd eq 'mount') {
        print <<EOF
    mount <virtual drive number> <file on host filesystem>

    Associate a file on the host filesystem with a virtual drive number.

    Virtual drive number is 0,1,2 or 3.

    Examples:
    mount 1 ../../foo.dsk
    mount 0 advent.bin
EOF
    }
    elsif ($cmd eq 'umount') {
        print <<EOF
    umount <virtual drive number>

    Close file associated with virtual drive number and make that virtual drive
    number available for reuse.

    Examples:
    umount 0
    umount 2
EOF
}
    elsif ($cmd eq 'info') {
        print <<EOF
    info

    Report host file, disk name and disk usage for all mounted disks.

    Examples:
    info
EOF
}
    elsif ($cmd eq 'clone') {
        print <<EOF
    clone <virtual drive number> <file on host filesystem>

    Make a copy of a virtual drive as a file on the host filesystem

    Virtual drive number is 0,1,2 or 3.

    This is exactly the same as doing copy on the host filesystem

    Examples:
    clone 1 ../../foo.dsk
    clone 0 advent.dsk
    clone 2 system.img
    clone 0 foo.zzz
    clone 0 bar.dsk
EOF
    }
    elsif ($cmd eq 'new') {
        print <<EOF
    new <file on host filesystem> [s=<num>]

    Create a file on the host filesystem that represents a blank disk.
    ANY EXISTING FILE OF THAT NAME WILL BE SILENTLY DELETED.

    The size of the disk can be specified. s=N creates a disk of N sectors.

    If the size is not specified it defaults to $SECTORS sectors. Each sector
    is $BYTES_SECTOR bytes.

    The disk image created is empty, with a valid, empty directory and a blank
    disk name. Mount the image and use 'name' to set the disk name.

    See 'help name'

    Examples:
    new foo.bin
    new bar.bin s=256
    mount 0 bar.bin
    name 0 BASIC Progs 27
EOF
    }
    elsif ($cmd eq 'copy') {
        print <<EOF
    copy <file specifier> <virtual drive specifier>

    Copy all of the files that match the file specifier (source) to the
    specified virtual drive (destination). Any files of the same name on the
    specified virtual drive are deleted.

    The syntax of this command does not allow the name of the file to be changed
    as a side-effect of the copy. Therefore, it is not legal for the source
    drive to match the destination drive. This restriction may be removed in the
    future.

    Examples:
    copy 2 3
    copy *.*:2 3
    copy *.TX:2 3
    copy ZOMBIE.BS:1 2
EOF
    }
    elsif ($cmd eq 'rename') {
        print <<EOF
    rename <file specifier> <new file specifier>

    Rename the file that matches the first file specifier to the name in the
    second file specifier. Any existing file of the same name on the
    virtual drive is deleted.

    The new file specifier must be on the same virtual drive.

    Both files can be specified using wildcards, but must each resolve to
    exactly one file. Be careful when using wildcards for the new name (see
    examples).

    Examples 1 -- all of these are equivalent, assuming only one source
                  match and that the new name does not match an existing file
    rename CHESS.GO:1 CHESS.XX:1
    rename CHESS.*:1 CHESS.XX:1
    rename C*.*:1 CHESS.XX:1

    Examples 2 -- the destination matches existing files Exec.OV and
                  Edit.OV and Ecmd.OV and Emsg.OV - it results in an error and
                  no rename occurs.
    rename CHESS.GO:1 E*.*:1

    Examples 3 -- the destination matches existing files Exec.OV and this
                  file is marked as deleted then CHESS.GO is renamed as
                  Edit.OV.
    rename CHESS.GO:1 Ex*.*:1
EOF
    }
    elsif ($cmd eq 'name') {
        print <<EOF
    name <virtual drive number> myname

    Change the name for the specified virtual drive number. The name is truncated
    after 20 characters.

    Example:
    name 1 mydisk
    name 0 fooo_by
EOF
    }
    elsif ($cmd eq 'type') {
        print <<EOF
    type <file specifier> [<conversions>] [<lines per page>]

    Display the contents of the specified files, <lines per page> lines at a
    time (default: $LINES_PER_PAGE).

    The default conversions are:
    TX=txt
    GO=dump
    xxx=dump

    See 'help conversions' for more details. See also 'help export'

    Example:
    type 1.*.TX TX=raw 25
    type 1.*.* TX=raw GO=nas xxx=dump
EOF
    }
    elsif ($cmd eq 'export') {
        print <<EOF
    export <file specifier> [<conversions>] [<path in host filesystem>]

    Copy the specified files to a directory in the host filesystem.  By default,
    the files will be saved in the current working directory but this can be
    overridden by specifying a path.

    The name part of an exported filename is the same as its name on the virtual
    disk. The extension part of the exported filename may be changed as a result
    of the export conversion as follows:

    raw, txt - extension unchanged
    nas, nasg - extension changed to .NAS
    cas, casg - extension changed to .CAS
    dump - extension changed to .DUMP

    Any existing file of the same name in the host filesystem will be
    overwritten.

    The default conversions are:
    TX=txt
    GO=raw
    xxx=raw

    See 'help conversions' for more details. See also 'help type'

    Example:
    export 1.*.TX TX=txt ../files
    export 0.*.GO GO=dump
    export 1.*.* TX=raw BS=dump xxx=raw some_subdirectory
EOF
    }
    elsif ($cmd eq 'import') {
        print <<EOF
    import <virtual drive number> <file on host filesystem> [<conversions>]

    Copy the specified file(s) to the specified virtual drive from the host
    filesystem. Files can be specified using wildcarding (see examples below).

    A file on the host filesystem that might otherwise be selected is silently
    ignored if it is zero bytes in size.

    The 'uppercase' command does not affect the wildcard matching of files in
    the host filesystem but does affect the name used for the imported file
    created on the virtual drive.

    The name part of the imported filename is truncated (if necessary) to 8
    characters. The extension part of the imported filename is truncated (if
    necessary) to 2 characters and may be changed as a result of the import
    conversion as follows:

    raw, txt - extension unchanged
    nas, cas - extension changed to .GO

    Any existing file of the same name on the virtual drive is deleted.

    An ambiguous situation arises if files with distinct names on the host
    filesystem end up with the same name (because of case conversion, truncation
    or import conversion) on the virtual drive. As each file in turn is
    processed, any existing file of the same name on the virtual drive is
    deleted.

    If there are insufficient free directory entries or free blocks on the
    virtual drive, the import will not proceed.

    The default conversions are:
    xxx=raw
    nas=nas
    cas=cas

    See 'help conversions' for more details. See also 'help uppercase'.

    To copy files between virtual drives, it is best to mount both virtual
    drives and use 'copy', rather than using an 'export'/'import'
    sequence. Using 'copy' ensures a byte-accurate copy.

    Example:
    hdir ../
    fred.txt Fred.TXT fred.CMD
    import 0 ../*.* xxx=raw         # uppercase=0: import 3 files
    import 0 ../*.* xxx=raw         # uppercase=1: either fred.tx
                                    # or Fred.TX will be overwritten
    import 0 ../*.TXT xxx=txt       # uppercase=0: import Fred.TX
                                    # as Fred.TX
    import 0 ../*.TXT xxx=txt       # uppercase=1: import Fred.TXT
                                    # as FRED.TX
EOF
    }
    elsif ($cmd eq 'dir') {
        print <<EOF
    dir <virtual drive number> | <file specifier>

    List all of the files on the specified virtual drive, or all of the files
    that match the file specifier. The file specifier can include * used as a
    wildcard.

    Examples:
    dir 2
    dir AS.GO:1
    dir F*.GO:1
    dir *.TX:1
    dir *A*.*:1
EOF
    }
    elsif ($cmd eq 'hdir') {
        print <<EOF
    hdir <host os arguments> <path in local file system>

    List files on the host filesystem. Just a convenience to avoid you having to
    shell out of polydos_vfs. All of the arguments supported by the host are
    also supported.

    Examples:
    hdir
    hdir .
    hdir -al ../
EOF
    }
    elsif ($cmd eq 'delete') {
        print <<EOF
    delete <virtual drive number> | <file specifier>

    Set the delete (D) flag on all of the files on the specified virtual drive,
    or all of the files that match the file specifier.  The file specifier can
    include * used as a wildcard.

    PolyDos will not allow deletion of a Locked file; polydos_vfs will allow it.

    BE CAREFUL -- NO CONFIRMATION IS ASKED FOR!

    Examples:
    delete 2
    delete NASDIS.GO:1
    delete F*.*:1
    delete *.OV:1
    delete *A*.*:1
EOF
    }
    elsif ($cmd eq 'undelete') {
        print <<EOF
    undelete <virtual drive number> | <file specifier>

    Clear the delete (D) flag on all of the files on the specified virtual drive,
    or all of the files that match the file specifier.  The file specifier can
    include * used as a wildcard.

    A deleted file cannot be undeleted if there is an existing undeleted file
    with the same name (rename the existing file first).

    If multiple deleted files of the same name exist, the oldest will be
    undeleted (the one that appears earliest in the directory listing) and an
    error reported for each other deleted file with the same name.

    Examples:
    undelete 2
    undelete NASDIS.GO:1
    undelete F*.*:1
    undelete *.OV:1
    undelete *A*.*:1
EOF
    }
    elsif ($cmd eq 'lock') {
        print <<EOF
    lock <virtual drive number> | <file specifier>

    Set the lock (L) flag on all of the files on the specified virtual drive, or
    all of the files that match the file specifier.  The file specifier can
    include * used as a wildcard.

    Examples:
    lock 2
    lock ZP.GO:1
    lock F*.*:1
    lock *.GO:1
    lock *A*.*:1
EOF
    }
    elsif ($cmd eq 'unlock') {
        print <<EOF
    unlock <virtual drive number> | <file specifier>

    Clear the lock (L) flag on all of the files on the specified virtual drive,
    or all of the files that match the file specifier.  The file specifier can
    include * used as a wildcard.

    Examples:
    lock 2
    lock ZP.GO:1
    lock F*.*:1
    lock *.GO:1
    lock *A*.*:1
EOF
    }
    elsif ($cmd eq 'attrib') {
        print <<EOF
    attrib <virtual drive number> | <file specifier> exe-hex [ load-hex ]

    Change attributes on all of the files on the specified virtual drive,
    or all of the files that match the file specifier.  The file specifier can
    include * used as a wildcard.

    exe-hex is the new execution address for the file. load-hex, if present, is
    the new load address for the file; both values must be in hex

    Examples:
    attrib 2 1000
    attrib INVADE.GO:1 1000 1000
    attrib *.BS:1 10d6 10d6
EOF
    }
    elsif ($cmd eq 'pack') {
        print <<EOF
    pack <virtual drive number>

    When deleted, a file still takes up disk space and a directory entry. To free
    up those resources, the disk must be packed: all of the deleted files are
    removed and the remaining files (and their directory entries) are shuffled
    back to free up space for reuse.

    Examples:
    pack 0
    pack 1
EOF
    }
    elsif ($cmd eq 'create') {
        print <<EOF
    create <file specifier> <number of sectors>

    Create a file by taking a number of sectors from the unallocated space on
    the virtual drive.

    The file specifier must not match an existing file name.

    Example:
    create SAVED.XX:1 5
EOF
    }
    elsif ($cmd eq 'check') {
        print <<EOF
    check <virtual drive number>

    Perform simple integrity tests on the disk directory. Specifically, check
    that:

    - sectors assigned to files start at sector 4
    - sectors are assigned sequentially and contiguously
    - the first free sector follows on from the last allocated sector

    Example:
    check 0
EOF
    }
    elsif ($cmd eq 'scrub') {
        print <<EOF
    scrub <virtual drive number>

    Over-write every unused directory entry and every unused sector with the
    values they would have on a freshly formatted disk.  The main motivation is
    to allow the resultant disk images to compress better.

    Example:
    scrub 0
EOF
    }
    elsif ($cmd eq 'repair') {
        print <<EOF
TODO - intended to repair any inconsistencies found by check. Not yet implemented
EOF
    }
    elsif ($cmd eq 'uppercase') {
        print <<EOF
    uppercase [0 | 1]

    PolyDos can use mixed-case file names and polydos_vfs allows this by
    default. However, in many cases, old disks have upper-case only file names
    and it can be tedious using the shift key continually.

    polydos_vfs can force all PolyDos file specifiers to upper case (note that
    wildcard '*' will still match both upper-case and lower-case if they exist
    on the disk).

    when upper-case forcing is enabled, filenames that are arguments to 'import'
    are forced to upper case.

    uppercase toggles the state of upper-case forcing. With an argument of 0 or
    1 it forces the state. In both cases, the new state is reported.

    Example:
    uppercase 0
    uppercase 1
EOF
    }
    elsif ($cmd eq 'files') {
        print <<EOF
    A file specifier in PolyDos consists of a file name, an extension and a
    drive number. They are arranged like this:

    <file name>.<extension>:<drive number>

    The name and extension can use the characters A-Z a-z 0-9 & - _

    The drive number (within polydos_vfs) can be 0-3

    The file name can be 1-8 characters long

    The extension must be exactly 2 characters. The following extensions
    are conventional:

    .TX - text file (including assembler source code)
    .GO - executable
    .OV - overlay
    .BS - BASIC program
    .DT - BASIC Data file
    .IN - information file

    In general, flex_vfs allows use of * for wildcarding. For example:

    dir *.TX:0
    dir C*.*:0

    You can't (currently) wildcard the drive number though.

    The PolyDos Users Guide implies that characters like !$%^&*()[]@#
    could be legal in file-names, but polydos_vfs does not permit them
    (please complain/raise a bug if you have reason to need any of these).
    In particular, polydos_vfs uses * for wildcarding so it cannot
    allow it in a filename.
EOF
    }
    elsif ($cmd eq 'formats') {
        print <<EOF
    Different PolyDos releases supported different disk drives, having different
    number of sectors/tracks/sides. In all cases, the sector size is contant
    (256 bytes) and PolyDos treats the disk as a linear sequence of sectors,
    starting at 0.

    All of the conversion between linear sector address and track/ sector/size
    takes place in the PolyDos ROM, effectively a hardware abstraction layer.

    Within polydos_vfs, you can mount disk images of different sizes (eg, from
    35-track and 40-track systems) and transfer data betweem them; the only
    requirement is that the sector count is correct in the directory data
    structure.

    However, PolyDos itself is not so flexible; it provides a SCAL DSIZ which
    reports the size of a disk (though on the SD/DD system 2 disk sizes can
    co-exist.
EOF
    }
    elsif ($cmd eq 'comments') {
        print <<EOF
    Command lines can include comments (useful for a script) in two different
    formats:

    (text in braces is treated as a comment and ignored)
    # text from a hash to the end of the line is ignored
EOF
    }
    elsif ($cmd eq 'conversions') {
        print <<EOF
    The export/type/import commands allow on-the-fly conversion of file
    formats. Conversion is selected based on file extension, allowing a group of
    files to be processed with a single command.

    Conversions supported for export/type:

    raw - a literal byte stream representing the data payload of every sector in
    the file. For a file of N sectors, the file will be 256*N bytes in size.

    txt - line endings are converted to CR/LF. Any NULL (0x00) bytes are
    removed.

    dump - hex and ASCII dump, 16 bytes per line

    nas - NASCOM "T" format - hex dump, 8 bytes per line

    nasg - NASCOM "G" format - hex dump, 8 bytes per line, ending with G and
    execution address.

    cas - NASCOM cassette format - byte stream.

    casg - NASCOM cassette format - byte stream, ending with G and execution
    address.

    Conversions supported for import:

    raw - a literal byte stream representing the data payload of the host
    file. A file of N bytes will require N*256 sectors; the final sector will be
    padded with NULL bytes.

    txt - line endings are converted to CR (Ctrl-M)

    nas - NASCOM "L" format. Hex dump 8 bytes per line, or 9 bytes (with
    checksum). If execution address is present (G) it will be used as the
    execute attribute for the file; otherwise, the load address will be used.

    cas - NASCOM cassette format - byte stream. If execution address is present
    (G) it will be used as the execute attribute for the file; otherwise, the
    load address will be used.

    Converters are selected based on file extension and can be set or overridden
    by specifying name/value pairs.

    For example:

    GO=raw TX=txt xxx=raw

    In this example, GO and TX are file extensions (case insensitive) and xxx
    defines the default conversion, which will be used for any file that does
    not match a defined extension.
EOF
    }
    elsif ($cmd eq 'scripts') {
        print <<EOF
    If you put a sequence of commands in a file you can run them by redirecting
    STDIN. For example, create a file sys.scr with this content:

# make a bootable system disk
mount 1 test1.img
new 2 boot.dsk
mount 2 boot.dsk
copy *.OV:1 2         # need overlays
copy SYSEQU.SY:1  2   # useful stuff
copy AS.GO:1  2       # useful stuff
exit

    From the command line invoke it like this:

\$ polydos_vfs < sys.scr

    The script *must* end with an 'exit' - there is no way (for example) to drop
    out of a script and continue interactively (that's a pity and I'd welcome
    suggestions that would make that work).
EOF
    } #'
    else {
        # no more to say about info, help, exit (or any non-existent command)
        print <<EOF
    No additional help is available on that topic
EOF
    }
}


sub help_generic {
    print <<EOF

polydos_vfs allows manipulation of up to 4 virtual drives, numbered 0 through 3.
Each drive can be associated with a file on the host filesystem. Files can be
copied between virtual drives or transferred between virtual drives and the host
filesystem. Virtual drives can be inspected and manipulated.

Usage:

    polydos_vfs
    polydos_vfs < script
    polydos_vfs foo.bin
    polydos_vfs *.bin

The first form starts an interactive session.
The second form runs a sequence of commands from a file (See 'help scripts').
The third form treats foo.bin as a disk image and does a mount/info/check/dir/exit.
The fourth form treats *.bin as a set of disk images and does a
mount/info/check/dir/exit
on each in turn.

Commands are:

    mount      - associate disk image with virtual drive number
    umount     - disconnect disk image from drive number
    info       - report virtual drives currently mounted
    clone      - make copy of virtual drive
    new        - create new empty disk image (optional size specification)
    copy       - copy file(s) from one virtual drive to another
    rename     - change name of file on virtual drive
    name       - change disk name
    type       - view file from virtual drive (optional format conversion)
    export     - copy file from virtual drive to local file system (optional format conversion)
    import     - copy file from local file system to virtual drive (optional format conversion)
    dir        - directory of virtual drive
    hdir       - directory of local file system
    delete     - set delete (D) flag on file(s) from virtual drive
    undelete   - clear delete (D) flag on file(s) from virtual drive
    lock       - set lock (L) flag on file(s) from virtual drive
    unlock     - clear lock (L) flag on file(s) from virtual drive
    attrib     - change execution/load address on file(s) from virtual drive
    pack       - remove deleted files and free up disk space and directory entries
    create     - create file from sector(s) on the free list
    repair     - perform low-level edit on virtual drive
    check      - check integrity of virtual drive
    scrub      - null out deleted file names and unused sectors
    uppercase  - treat all PolyDos file specifiers as upper-case
    exit       - unmount all mounted drives and leave polydos_vfs
    quit       - synonym for exit
    help       - this is it.

Other help topics: files formats comments conversions scripts

Type help <command name> or help <topic> for more help.
EOF
}
